Roadmap C: Abordagem Híbrida (Single-Player Robusto + Multiplayer Validado)

Este documento apresenta um terceiro caminho de desenvolvimento que combina os pontos fortes dos Roadmaps A e B, priorizando uma base sólida com arquitetura preparada para expansão online desde o início.

Filosofia: "Construir uma experiência single-player completa e testada localmente, mas com arquitetura e estrutura de código preparadas para multiplayer desde o dia 1. Isso permite validar a lógica do jogo rapidamente enquanto facilita a transição para modo online quando estiver pronto."

FASE 1: Fundação React + Arquitetura Preparada para Multiplayer (2-3 semanas)

Objetivo: Criar uma base de código organizada, componentizada e arquiteturalmente preparada para suportar tanto modo local quanto online, sem complexidade desnecessária inicialmente.

Ação Principal: Migrar o protótipo HTML/JS para React.js com uma arquitetura que abstraia a fonte de dados do estado do jogo.

Tarefas Detalhadas:

1.1. Estruturação do Projeto React
- Inicializar projeto React (com Vite ou Create React App).
- Configurar TypeScript (recomendado para melhor manutenibilidade).
- Estruturar pastas seguindo a organização modular:
  ├── src/
  │   ├── game/
  │   │   ├── GameState.ts          # Interfaces e tipos do estado do jogo
  │   │   ├── gameLogic.ts          # Funções puras de lógica (regras, validações)
  │   │   └── ai/
  │   │       ├── aiStrategies.ts   # Lógica de IA (baseada em probabilidade)
  │   │       └── aiPersonalities.ts # Personalidades de IA (futuro)
  │   ├── state/
  │   │   ├── useLocalGame.ts       # Hook para gerenciar jogo local
  │   │   └── useOnlineGame.ts      # Hook para gerenciar jogo online (placeholder)
  │   ├── components/
  │   │   ├── GameBoard.tsx         # Componente principal do jogo
  │   │   ├── PlayerArea.tsx        # Área de um jogador (reutilizável)
  │   │   ├── Controls.tsx          # Controles de aposta e dúvida
  │   │   ├── DiceDisplay.tsx       # Componente visual dos dados
  │   │   └── MessageDisplay.tsx    # Exibição de mensagens do jogo
  │   ├── services/
  │   │   ├── firebase.ts           # Configuração Firebase (inicialização)
  │   │   └── gameStateAdapter.ts   # Adaptador que abstrai fonte de dados
  │   └── types/
  │       └── index.ts              # Tipos TypeScript compartilhados

1.2. Definição da Arquitetura de Dados
- Criar interface GameState que suporta múltiplos jogadores:
  ```typescript
  interface GameState {
    players: Player[];
    currentPlayerIndex: number;
    currentBid: Bid | null;
    lastRoundLoserIndex: number;
    roundNumber: number;
    gameStatus: 'waiting' | 'playing' | 'finished';
  }
  
  interface Player {
    id: string;
    name: string;
    dice: number[];
    isHuman: boolean;
    isAI?: boolean;
  }
  ```
- Refatorar lógica existente para trabalhar com array de jogadores (não apenas player/ai).

1.3. Migração do Código para Componentes React
- Criar componente <GameBoard> que gerencia o estado geral.
- Criar componente <PlayerArea> reutilizável (pode ser usado para jogador humano e IAs).
- Extrair funções puras de lógica do jogo (isValidBid, resolveChallenge, etc.) para gameLogic.ts.
- Manter a lógica de IA separada em aiStrategies.ts.

1.4. Sistema de Hooks para Gerenciamento de Estado
- Implementar useLocalGame.ts:
  - Gerencia estado do jogo em memória (useState/useReducer).
  - Expõe funções: makeBid(), challenge(), startNewRound().
  - Usado para modo single-player.
- Criar esqueleto de useOnlineGame.ts (não implementado ainda, apenas interface):
  - Mesma interface que useLocalGame, mas preparado para ler/escrever do Firestore.
  - Componente GameBoard pode alternar entre os dois hooks.

1.5. Configuração Inicial do Firebase (Sem Uso Ainda)
- Criar projeto Firebase.
- Configurar Firebase Authentication (sem integração ainda).
- Configurar Firestore (sem leitura/escrita ainda).
- Criar arquivo services/firebase.ts com inicialização.
- Definir schema mental do Firestore (collections: games, users).

1.6. Implementação de 1 vs 1 IA (Modo Local)
- Adaptar o jogo para funcionar com 2 jogadores (humano + 1 IA).
- Implementar lógica de turnos baseada em currentPlayerIndex.
- Garantir que a IA funcione corretamente com nova estrutura.

Resultado Esperado da Fase 1:
- Projeto React funcional com jogo 1v1 local vs IA.
- Código organizado em componentes reutilizáveis.
- Arquitetura preparada para adicionar multiplayer (hooks, interfaces).
- Firebase configurado (mas não integrado ainda).

FASE 2: Multiplayer Básico 1v1 Online (1-2 semanas)

Objetivo: Validar a arquitetura online e permitir que duas pessoas reais joguem juntas. Foco em funcionalidade básica, não em polimento.

Ação Principal: Integrar Firestore como fonte de dados do estado do jogo, substituindo o estado local quando em modo online.

Tarefas Detalhadas:

2.1. Implementação do Hook useOnlineGame
- Implementar leitura de estado do jogo do Firestore (onSnapshot).
- Implementar escrita de apostas no Firestore.
- Implementar chamada à Cloud Function para resolver desafios.
- Garantir que useOnlineGame tenha a mesma interface que useLocalGame.

2.2. Estrutura de Dados no Firestore
- Criar collection 'games' com documentos:
  ```
  games/{gameId}/
    - players: array
    - currentPlayerIndex: number
    - currentBid: object | null
    - lastRoundLoserIndex: number
    - gameStatus: string
    - createdAt: timestamp
    - updatedAt: timestamp
  ```
- Criar collection 'gamePlayers' para dados privados:
  ```
  gamePlayers/{gameId}/{playerId}/
    - dice: array (dados do jogador, privados)
  ```

2.3. Implementação de Cloud Function para Resolução de Desafios
- Criar Cloud Function 'resolveChallenge':
  - Recebe gameId como parâmetro.
  - Lê todos os dados dos jogadores (incluindo dados privados).
  - Executa lógica de resolução (conta dados, determina perdedor).
  - Atualiza estado do jogo no Firestore.
  - Garantia de integridade (impossível fraudar).

2.4. Sistema de Lobby Básico
- Criar tela de Lobby:
  - Mostra userId do jogador (para compartilhar).
  - Botão "Criar Sala" (cria documento no Firestore).
  - Campo "Entrar por Código" (lê documento do Firestore).
  - Lista de salas públicas (opcional, para Fase 3).

2.5. Autenticação de Usuários
- Integrar Firebase Authentication.
- Tela de Login/Registro (email/senha ou Google).
- Proteger rotas que requerem autenticação.

2.6. Testes com Jogadores Reais
- Testar partida completa 1v1 entre duas pessoas.
- Validar sincronização em tempo real.
- Identificar e corrigir bugs de sincronização.

Resultado Esperado da Fase 2:
- Dois jogadores podem criar uma sala e jogar juntos online.
- Sincronização em tempo real funcional.
- Resolução de desafios segura (Cloud Function).
- Validação da proposta de valor social do jogo.

FASE 3: Polimento e Expansão (2-3 semanas)

Objetivo: Melhorar a experiência single-player e adicionar funcionalidades essenciais de multiplayer. Tornar o jogo mais envolvente e completo.

Ação Principal: Expandir ambos os modos (local e online) com melhorias de IA, mais jogadores e funcionalidades sociais básicas.

Tarefas Detalhadas:

3.1. Expansão do Modo Single-Player (1 vs 3 IAs)
- Adicionar suporte para 4 jogadores (humano + 3 IAs).
- Implementar lógica de turnos para múltiplos jogadores.
- Criar interface visual que mostra os 3 oponentes ao redor da mesa.
- Adaptar lógica de IA para funcionar em contexto multiplayer.

3.2. Melhoria da Inteligência Artificial
- Implementar IA baseada em probabilidade:
  - Calcular chance de aposta ser verdadeira com base nos próprios dados.
  - Considerar total de dados na mesa.
  - Considerar coringas (dados de valor 1).
- Criar personalidades de IA:
  - IA Cautelosa: Só aumenta apostas com alta confiança, duvida frequentemente.
  - IA Agressiva: Aumenta apostas mesmo com dados ruins, pressiona oponentes.
  - IA Analítica: Tenta detectar padrões nas apostas dos oponentes.
- Permitir seleção de personalidades antes de iniciar partida.

3.3. Regras Especiais
- Implementar regra "Palafico" (quando jogador fica com 1 dado):
  - Dados de valor 1 não são mais coringas.
  - Apostas devem ser feitas apenas em dados de valor 1.
- Adicionar animações e feedback visual para regras especiais.

3.4. Matchmaking Público
- Criar sistema de "fila" no Firestore:
  - Collection 'matchmakingQueue' com documentos temporários.
  - Jogadores entram na fila clicando "Partida Rápida".
  - Quando 2 jogadores estão na fila, cria partida automaticamente.
  - Cloud Function para gerenciar matchmaking.

3.5. Sistema de Ranking Básico
- Adicionar campo 'elo' ou 'rating' na collection 'users'.
- Atualizar ranking após cada partida (Cloud Function).
- Criar tela de Leaderboard:
  - Top 10 jogadores globalmente.
  - Top 10 entre amigos (futuro).
- Atualização em tempo real do ranking.

3.6. Melhorias de UI/UX
- Animações de dados sendo rolados.
- Feedback visual para apostas e dúvidas.
- Sons e efeitos (opcional, mas recomendado).
- Design responsivo para mobile.

Resultado Esperado da Fase 3:
- Modo single-player completo e desafiador (1 vs 3 IAs).
- Multiplayer com matchmaking público funcional.
- Sistema de ranking implementado.
- Experiência de jogo polida e envolvente.

FASE 4: Funcionalidades Avançadas (3-4 semanas)

Objetivo: Expandir o jogo para suportar mais jogadores online e adicionar sistemas de engajamento e personalização.

Ação Principal: Implementar funcionalidades que aumentam o valor de replay e o engajamento dos jogadores.

Tarefas Detalhadas:

4.1. Suporte a 4-8 Jogadores Online
- Refatorar lógica de jogo para suportar até 8 jogadores.
- Adaptar interface para exibir múltiplos jogadores.
- Implementar sistema de "eliminação" quando jogador perde todos os dados.
- Garantir que partidas com muitos jogadores sejam rápidas (timeouts, etc.).

4.2. Sistema de Amigos e Lobby Privado
- Implementar lista de amigos:
  - Enviar/solicitar/aceitar amizades.
  - Collection 'friendships' no Firestore.
- Criar lobby privado:
  - Criar sala e convidar amigos diretamente.
  - Lista de amigos online.
  - Notificações de convites.

4.3. Partidas Ranqueadas
- Criar modo de jogo separado "Ranqueado":
  - Matchmaking apenas com jogadores de rating similar.
  - Sistema de seasons/temporadas.
  - Recompensas ao final da temporada (futuro).
- Implementar sistema de ELO/MMR:
  - Ganho/perda de pontos baseado em rating do oponente.
  - Cloud Function para calcular mudanças de rating.

4.4. Sistema de Conquistas (Achievements)
- Definir lista de conquistas:
  - "Primeira Vitória", "10 Vitórias", "Duvidou e Ganhou", etc.
- Collection 'achievements' no Firestore.
- Exibir conquistas no perfil do jogador.
- Notificações quando conquista é desbloqueada.

4.5. Personalização Cosmética
- Sistema de desbloqueio de itens:
  - Dados temáticos (cores, estilos).
  - Copos personalizados.
  - Avatares.
- Collection 'playerCosmetics' no Firestore.
- Loja/tela de personalização.

4.6. Estatísticas de Perfil
- Página de perfil detalhada:
  - % de vitórias.
  - Total de partidas jogadas.
  - Maior sequência de vitórias.
  - Estatísticas por modo (single-player, multiplayer, ranqueado).
- Histórico de partidas recentes (últimas 10).
- Gráficos de progresso (opcional).

4.7. Eventos e Modos Especiais
- Implementar sistema de eventos:
  - Modos de fim de semana (ex: "Todos os dados valem 1").
  - Torneios programados.
- Cloud Functions para gerenciar eventos.
- Notificações de eventos ativos.

Resultado Esperado da Fase 4:
- Jogo completo com suporte a até 8 jogadores.
- Sistema social completo (amigos, lobbies privados).
- Modo ranqueado funcional.
- Sistemas de engajamento (conquistas, cosméticos, estatísticas).
- Base sólida para expansão futura.

FASE 5: Otimização e Lançamento (2-3 semanas)

Objetivo: Preparar o jogo para lançamento público, focando em performance, estabilidade e experiência do usuário.

Ação Principal: Otimizações, testes extensivos e preparação para escala.

Tarefas Detalhadas:

5.1. Otimização de Performance
- Otimizar queries do Firestore (índices, paginação).
- Implementar cache local quando apropriado.
- Reduzir número de leituras/escritas no Firestore.
- Otimizar bundle size (code splitting, lazy loading).

5.2. Testes e Debugging
- Testes de carga (simular múltiplas partidas simultâneas).
- Testes de sincronização (simular latência, desconexões).
- Correção de bugs críticos.
- Testes de usabilidade com usuários reais.

5.3. Segurança e Validação
- Validação de regras do jogo no backend (Cloud Functions).
- Proteção contra trapaças (validação de apostas no servidor).
- Rate limiting para prevenir abuso.
- Sanitização de inputs.

5.4. Documentação e Onboarding
- Tutorial interativo para novos jogadores.
- Documentação de regras do jogo dentro do app.
- FAQ/Troubleshooting.
- Guia de estratégias básicas.

5.5. Preparação para Lançamento
- Configurar domínio e hospedagem (Firebase Hosting).
- Configurar analytics (Firebase Analytics ou Google Analytics).
- Implementar sistema de feedback/relatórios de bugs.
- Preparar materiais de marketing (screenshots, descrição, etc.).

5.6. Beta Testing
- Lançar versão beta para grupo limitado de testadores.
- Coletar feedback e fazer ajustes.
- Identificar e corrigir problemas críticos.

Resultado Esperado da Fase 5:
- Jogo otimizado e estável.
- Pronto para lançamento público.
- Base de código mantível e escalável.
- Sistema de feedback e analytics implementado.

COMPARAÇÃO DOS ROADMAPS

Fator                  Roadmap A      Roadmap B      Roadmap C (Híbrido)
─────────────────────────────────────────────────────────────────────────
Tempo até MVP          4-6 semanas    2-3 semanas    3-4 semanas
Validação Social       Tardia         Rápida         Intermediária
Base de Código         Sólida         Rápida         Sólida
Risco Técnico          Baixo          Alto           Médio
Validação de Mercado   Tardia         Rápida         Intermediária
Retrabalho             Potencial      Mínimo         Mínimo
Complexidade Inicial   Média          Alta           Média-Alta

VANTAGENS DO ROADMAP C (Híbrido)

1. Validação Incremental
   - Tem algo jogável rapidamente (Fase 1).
   - Valida arquitetura online antes de investir muito tempo (Fase 2).
   - Expande ambos os modos de forma equilibrada (Fase 3).

2. Arquitetura Correta desde o Início
   - Não precisa refatorar código para adicionar multiplayer.
   - Hooks e abstrações facilitam manutenção.
   - Código reutilizável entre modos local e online.

3. Menor Risco
   - Se houver problemas com Firebase/rede, o modo local já funciona.
   - Pode lançar versão single-player enquanto corrige multiplayer.
   - Testa complexidade técnica cedo, mas com base sólida.

4. Desenvolvimento Paralelo
   - Pode polir single-player enquanto testa multiplayer.
   - Funcionalidades podem ser desenvolvidas independentemente.
   - Facilita trabalho em equipe (se aplicável).

5. Flexibilidade
   - Pode ajustar prioridades baseado em feedback.
   - Não fica preso a um único caminho.
   - Permite iteração rápida.

DESAFIOS E CONSIDERAÇÕES

1. Complexidade Inicial
   - Requer mais planejamento arquitetural.
   - Abstrações podem ser difíceis de implementar corretamente.
   - Mitigação: Começar simples, refatorar quando necessário.

2. Tempo de Desenvolvimento
   - Pode levar um pouco mais que Roadmap B para primeira versão online.
   - Mitigação: Foco em MVP funcional, não em perfeição.

3. Manutenção de Dois Modos
   - Precisa garantir que ambos os modos funcionem.
   - Mitigação: Lógica de jogo compartilhada (gameLogic.ts).

ESTRUTURA DE CÓDIGO RECOMENDADA

```
src/
├── game/
│   ├── GameState.ts          # Interfaces e tipos
│   ├── gameLogic.ts          # Regras puras (sem dependências)
│   └── ai/
│       ├── aiStrategies.ts
│       └── aiPersonalities.ts
├── state/
│   ├── useLocalGame.ts       # Hook para jogo local
│   └── useOnlineGame.ts      # Hook para jogo online
├── components/
│   ├── GameBoard.tsx         # Usa useLocalGame ou useOnlineGame
│   ├── PlayerArea.tsx
│   ├── Controls.tsx
│   ├── DiceDisplay.tsx
│   └── MessageDisplay.tsx
├── services/
│   ├── firebase.ts
│   └── gameStateAdapter.ts   # Abstração de fonte de dados
└── types/
    └── index.ts
```

CONSIDERAÇÕES FINAIS

O Roadmap C (Híbrido) oferece o melhor equilíbrio entre:
- Validação rápida da proposta de valor
- Base de código sólida e manutenível
- Flexibilidade para ajustar prioridades
- Redução de risco técnico

É ideal para projetos que:
- Querem validar o mercado rapidamente, mas não às custas da qualidade
- Precisam de uma base sólida para escalar
- Têm recursos limitados e precisam maximizar eficiência
- Querem flexibilidade para ajustar estratégia baseado em feedback

Este roadmap permite que você tenha um jogo funcional e jogável rapidamente, enquanto constrói a arquitetura certa para suportar todas as funcionalidades futuras planejadas.
